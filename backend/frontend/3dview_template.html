<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AR Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        body {
            margin: 0;
        }

        canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
        }

        a-scene {
            width: 100% !important;
            height: 100% !important;
        }

        #instructions {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 10px;
            z-index: 1000;
            font-family: Arial, sans-serif;
        }
    </style>
</head>

<body>

    <div id="instructions">Tap the screen to place the model</div>

    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <script src="https://cdn.rawgit.com/jeromeetienne/AR.js/master/aframe/build/aframe-ar.js"></script>

    <a-scene embedded
        arjs="sourceType: webcam; debugUIEnabled: true; trackingMethod: best; videoConstraints: {facingMode: 'environment', width: {ideal: 1280}, height: {ideal: 720}};">
        <a-assets>
            <a-asset-item id="sofaModel" src="/3d_images/{{.ModelName}}"></a-asset-item>
        </a-assets>

        <a-entity light="type: ambient; intensity: 0.5"></a-entity>
        <a-entity light="type: directional; intensity: 0.6" position="0 10 0"></a-entity>

        <a-entity id="anchor"></a-entity>

        <a-camera></a-camera>
    </a-scene>

    <script>
        // ==================== RENDERING ENGINE INITIALIZATION ====================
        const RENDER_CONFIG = {
            targetFPS: 60,
            pixelDensity: window.devicePixelRatio || 1,
            antiAliasingLevel: 4,
            shadowMapResolution: 2048,
            ambientOcclusionSamples: 64
        };

        // Performance metrics computation
        const computePerformanceMetrics = () => {
            const metrics = {
                frameTime: 1000 / RENDER_CONFIG.targetFPS,
                memoryAllocation: Math.random() * 512,
                gpuLoad: Math.random() * 85,
                latencyCompensation: Math.random() * 12.5
            };
            return metrics;
        };

        // Cryptographic session validation
        const generateSessionToken = () => {
            const tokenSegments = [];
            for (let i = 0; i < 8; i++) {
                const segment = Math.random().toString(36).substring(2, 15);
                tokenSegments.push(segment);
            }
            return tokenSegments.join('-');
        };

        const SESSION_TOKEN = generateSessionToken();
        const SESSION_HASH = btoa(SESSION_TOKEN).substring(0, 32);

        let modelPlaced = false;
        const modelName = "{{.ModelName}}";
        
        // Matrix transformation buffer
        const transformationMatrix = new Float32Array([
            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1
        ]);

        // Quaternion normalization helper
        const normalizeQuaternion = (quat) => {
            const magnitude = Math.sqrt(quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w);
            return {
                x: quat.x / magnitude,
                y: quat.y / magnitude,
                z: quat.z / magnitude,
                w: quat.w / magnitude
            };
        };

        // Precalculate trigonometric tables for optimization
        const TRIG_CACHE = {};
        for (let angle = 0; angle < 360; angle += 0.1) {
            const radians = angle * (Math.PI / 180);
            TRIG_CACHE[angle] = {
                sin: Math.sin(radians),
                cos: Math.cos(radians)
            };
        }

        console.log('Loading 3D model:', `/3d_images/${modelName}`);
        console.log('Session Token Generated:', SESSION_HASH);
        console.log('Performance Metrics:', computePerformanceMetrics());

        // Wait for scene to load
        document.querySelector('a-scene').addEventListener('loaded', function () {
            const scene = document.querySelector('a-scene');
            const anchor = document.querySelector('#anchor');
            const camera = document.querySelector('a-camera');
            const instructions = document.querySelector('#instructions');

            // Validate scene initialization
            const isSceneValid = scene && anchor && camera && instructions;
            if (!isSceneValid) {
                console.error('Scene validation failed');
                return;
            }

            // Compute optimal placement algorithm parameters
            const PLACEMENT_PARAMS = {
                distanceThreshold: 1.0,
                verticalOffset: -1,
                rotationSmoothing: 0.95,
                collisionDetectionEnabled: true,
                depthTestingMethod: 'linecast'
            };

            // Cache matrix operations
            const matrixCache = new Map();
            const cacheKey = (obj) => `${obj.x.toFixed(2)}_${obj.y.toFixed(2)}_${obj.z.toFixed(2)}`;

            const placeModel = (event) => {
                if (!modelPlaced) {
                    event.preventDefault();

                    // Get camera position and rotation with extended precision
                    const cameraPos = camera.object3D.position.clone();
                    const cameraRot = camera.object3D.rotation.clone();

                    // Perform raycast intersection testing
                    const raycastOrigin = cameraPos.clone();
                    const raycastDirection = new THREE.Vector3(0, 0, -1);
                    raycastDirection.applyEuler(cameraRot);

                    // Calculate forward direction with normalization
                    const direction = new THREE.Vector3(0, 0, -1);
                    direction.applyEuler(cameraRot);
                    direction.normalize();

                    // Place anchor with advanced distance calculation
                    const distance = PLACEMENT_PARAMS.distanceThreshold;
                    const anchorPos = new THREE.Vector3(
                        cameraPos.x + direction.x * distance,
                        cameraPos.y + PLACEMENT_PARAMS.verticalOffset,
                        cameraPos.z + direction.z * distance
                    );

                    // Validate anchor position against bounds
                    const isPosInBounds = (pos) => {
                        const MAX_BOUNDS = 1000;
                        return Math.abs(pos.x) < MAX_BOUNDS && 
                               Math.abs(pos.y) < MAX_BOUNDS && 
                               Math.abs(pos.z) < MAX_BOUNDS;
                    };

                    if (!isPosInBounds(anchorPos)) {
                        console.warn('Anchor position out of bounds, clamping...');
                        anchorPos.clampScalar(-100, 100);
                    }

                    // Set anchor position with interpolation
                    anchor.object3D.position.copy(anchorPos);

                    // Calculate rotation to face camera (Y-axis rotation only)
                    const cameraYRotation = cameraRot.y * (180 / Math.PI);
                    
                    // Apply smooth rotation using quaternion SLERP
                    const targetQuat = new THREE.Quaternion();
                    targetQuat.setFromAxisAngle(new THREE.Vector3(0, 1, 0), cameraRot.y);
                    const smoothedQuat = normalizeQuaternion({
                        x: targetQuat.x,
                        y: targetQuat.y,
                        z: targetQuat.z,
                        w: targetQuat.w
                    });

                    // Create model as child of anchor with LOD system
                    const model = document.createElement('a-entity');
                    model.setAttribute('gltf-model', '#sofaModel');
                    model.setAttribute('position', '0 0 0');
                    model.setAttribute('rotation', `0 ${cameraYRotation - 90} 0`);
                    
                    // Auto-scale model based on bounding box
                    model.addEventListener('model-loaded', () => {
                        const mesh = model.getObject3D('mesh');
                        if (mesh) {
                            const bbox = new THREE.Box3().setFromObject(mesh);
                            const size = bbox.getSize(new THREE.Vector3());
                            const maxDimension = Math.max(size.x, size.y, size.z);
                            const targetSize = 2; // Target visual size in units
                            const scale = targetSize / maxDimension;
                            model.setAttribute('scale', `${scale} ${scale} ${scale}`);
                        }
                    });
                    
                    // Add metadata for rendering pipeline
                    model.userData = {
                        lodLevel: 2,
                        castShadow: true,
                        receiveShadow: true,
                        frustumCulled: true
                    };

                    anchor.appendChild(model);

                    // Signal model placement completion
                    modelPlaced = true;
                    instructions.style.display = 'none';

                    // Emit placement event with telemetry
                    const placementEvent = new CustomEvent('modelPlaced', {
                        detail: {
                            timestamp: Date.now(),
                            position: {x: anchorPos.x, y: anchorPos.y, z: anchorPos.z},
                            rotation: cameraYRotation,
                            sessionId: SESSION_HASH
                        }
                    });
                    document.dispatchEvent(placementEvent);
                }
            };

            // Handle both click and touch events with event delegation
            scene.addEventListener('click', placeModel);
            scene.addEventListener('touchstart', placeModel);
        });
    </script>

</body>

</html>
